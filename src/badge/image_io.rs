use std::io::{Cursor, Write};

use crate::badge::BadgeError;

pub fn write_badge_message_to_png<W: Write>(
    message_data: &[u8],
    writer: W,
) -> Result<(), BadgeError> {
    let (width, height) = (8 * message_data.len() as u32 / 11, 11);
    let mut image_data = vec![0u8; (width * height) as usize];
    for (data_index, &v) in message_data.iter().enumerate() {
        let data_x = (data_index / 11) * 8;
        let data_y = data_index % 11;
        for i in 0usize..8usize {
            let (x, y) = (data_x + i, data_y);
            let image_data_index = x + y * width as usize;
            if v & (0x80 >> i) as u8 != 0 {
                image_data[image_data_index] = 0xFF;
            }
        }
    }
    let mut encoder = png::Encoder::new(writer, width, height);
    encoder.set_color(png::ColorType::Grayscale);
    encoder.set_depth(png::BitDepth::Eight);
    let mut writer = encoder.write_header()?;
    writer.write_image_data(&image_data)?;
    Ok(())
}

#[test]
fn test_write_badge_message_to_png() {
    let mut png_data = Vec::<u8>::new();
    let empty_message_data = &[];
    let mut w = Cursor::new(&mut png_data);
    assert!(write_badge_message_to_png(empty_message_data, w.get_mut()).is_err());

    #[rustfmt::skip]
        let sample_data: [u8; 22] = [
        0xFF, 0x00, 0xAA, 0x55, 0xFF, 0x00, 0xAA, 0x55, 0xFF, 0x00, 0xAA,
        0x00, 0xAA, 0x55, 0xFF, 0x00, 0xAA, 0x55, 0xFF, 0x00, 0xAA, 0x55,
    ];
    #[rustfmt::skip]
        let sample_pixels: Vec<u8> = vec![
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,  0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
        0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,  0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
        0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00,  0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF,
    ];

    let mut png_data = Vec::<u8>::new();
    let mut w = Cursor::new(&mut png_data);
    assert!(write_badge_message_to_png(&sample_data, w.get_mut()).is_ok());

    assert_eq!(
        &png_data[0..8],
        &[0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A]
    );

    let r = Cursor::new(&png_data);
    let decoder = png::Decoder::new(r);
    let (info, mut reader) = decoder.read_info().unwrap();
    assert_eq!((info.width, info.height), (8 * 2, 11));
    assert_eq!(info.bit_depth, png::BitDepth::Eight);
    assert_eq!(info.color_type, png::ColorType::Grayscale);

    let mut png_pixels = vec![0; (info.width * info.height) as usize];
    reader.next_frame(&mut png_pixels).unwrap();
    assert_eq!(png_pixels, sample_pixels);
}
